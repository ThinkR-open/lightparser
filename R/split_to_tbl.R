# WARNING - Generated by {fusen} from dev/flat_split_combine.Rmd: do not edit by hand

#' Group lines of a Rmd or Qmd file by types in a tibble
#'
#' @param file A Rmd or Qmd file path
#' @return A tibble with 6 columns:
#' - `type`: type of the part (yaml, heading, inline, block)
#' - `label`: label of the part (if any)
#' - `params`: parameters of the part (if any)
#' - `text`: text of the part (if any)
#' - `code`: code of the part (if any)
#' - `heading`: heading of the part (if any)
#'
#' @importFrom tibble tibble
#' @importFrom utils getFromNamespace
#'
#' @export
#' @examples
#' file <- system.file(
#'   "dev-template-parsing.Rmd",
#'   package = "lightparser"
#' )
#' split_to_tbl(file)
split_to_tbl <- function(file) {
  rmd_lines <- readLines(file)
  # Get yaml header
  if (!grepl("^---$", rmd_lines[1])) {
    stop(
      "Flat file parsed needs to have a yaml header",
      " starting from line 1 with: ---"
    )
  }
  yaml_begin <- 1
  yaml_end <- which(grepl("^---", rmd_lines))[2]
  yaml_content <- yaml::yaml.load(rmd_lines[yaml_begin:yaml_end])
  yaml_tbl <- tibble(
    type = "yaml",
    label = NA,
    params = list(yaml_content),
    text = NA,
    code = NA,
    heading = NA
  )

  # Get the rest of the document without yaml
  rmd_lines_no_yaml <- rmd_lines[-c(yaml_begin:yaml_end)]

  # TODO - In another process for knit in knit
  # dput(rmd_lines_no_yaml)
  # Are we inside a Rmd/Qmd that is currently knitted ?
  # If so, we cannot use knitr::split_file() in the current session
  # because it will affect the hidden knit environment variables.
  outside_knit <- is.null(knitr::opts_knit$get("out.format"))

  if (outside_knit) {
    res_split <- knitr_split(rmd_lines_no_yaml)
  } else {
    message(
      "It seems you are currently knitting a Rmd/Qmd file.",
      " The parsing of the file will be done in a new R session."
    )
    # tempfile_code_in <- normalizePath(
    #   tempfile(fileext = ".R"),
    #   mustWork = FALSE,
    #   winslash = "/"
    # )
    # tempfile_data_in <- normalizePath(
    #   tempfile(fileext = ".R"),
    #   mustWork = FALSE,
    #   winslash = "/"
    # )
    # tempfile_data_out <- normalizePath(
    #   tempfile(fileext = ".R"),
    #   mustWork = FALSE,
    #   winslash = "/"
    # )

    # dput(rmd_lines_no_yaml, file = tempfile_data_in)
    # code_to_run <- sprintf(
    #   paste(
    #     c(
    #       "cat('Run in external session')",
    #       "rmd_lines_no_yaml <- dget('%s')",
    #       paste0(
    #         "res_split <- getFromNamespace('knitr_split',",
    #         " 'lightparser')(rmd_lines_no_yaml)"
    #       ),
    #       "dput(res_split, file = '%s')"
    #     ),
    #     collapse = "\n"
    #   ),
    #   tempfile_data_in,
    #   tempfile_data_out
    # )
    # cat(code_to_run, file = tempfile_code_in)
    # Use bin/R and not bin/Rscript as
    # it does not work on Windows...
    # For unknown reason

    # for windows ?
    # outsystem <- system(
    #   paste0(
    #     normalizePath(file.path(Sys.getenv("R_HOME"), "bin", "R"),
    #       mustWork = FALSE
    #     ),
    #     ' -e source("',
    #     tempfile_code_in,
    #     '")'
    #   )
    # )

    # # for others
    # outsystem <- system(
    #   paste0(
    #     normalizePath(file.path(Sys.getenv("R_HOME"), "bin", "Rscript"),
    #       mustWork = FALSE
    #     ),
    #     " -e ",
    #     tempfile_code_in
    #   )
    # )


    res_split <- callr::r(function() knitr_split(rmd_lines_no_yaml),
      package = TRUE
    )

    # rstudioapi::navigateToFile(tempfile_code_in)
    # res_split <- dget(tempfile_data_out)
    # file.remove(
    #   c(tempfile_code_in, tempfile_data_in, tempfile_data_out)
    # )
  }

  res_split$text <- lapply(res_split$text, split_headers_from_text)
  res_split <- tidyr::unnest(res_split, cols = text)
  # Get headings
  res_split$heading <- sapply(
    seq_len(nrow(res_split)),
    function(x) {
      if (grepl("heading", names(res_split$text)[x])) {
        gsub("^#*\\s*", "", res_split$text[x])
      } else {
        NA
      }
    }
  )

  res_split$type[!is.na(res_split$heading)] <- "heading"

  # Put back yaml in 'res'
  res_full <- rbind(yaml_tbl, res_split)

  return(res_full)
}

#' Split text and chunks from a Rmd or Qmd file into a tibble
#' @noRd
knitr_split <- function(rmd_lines_no_yaml) {
  # Use hidden functions of {knitr}
  # Code extracted will be stored in a new environment
  # with `knitr:::split_file()`
  # Using `knitr::knit_code$restore()` makes sure there is no current Rmd to be
  # splitted
  # Is it compatible with the function beeing included in a Rmd file ?
  # We'll see.
  getFromNamespace("knit_log", "knitr")$restore()
  knitr::knit_code$restore()
  getFromNamespace("chunk_counter", "knitr")(reset = TRUE)
  options(knitr.duplicate.label = "allow")
  # Restore after splitting
  on.exit(options(knitr.duplicate.label = NULL), add = TRUE)
  # restore unnamed-chunk counter
  on.exit(getFromNamespace("chunk_counter", "knitr")(reset = TRUE), add = TRUE)
  on.exit(knitr::knit_code$restore(), add = TRUE)
  on.exit(getFromNamespace("knit_log", "knitr")$restore(), add = TRUE)


  # Split files
  out <- getFromNamespace("split_file", "knitr")(
    rmd_lines_no_yaml,
    patterns = getFromNamespace("all_patterns", "knitr")$md,
    set.preamble = TRUE
  )

  res <- tibble(
    type = sapply(out, class),
    label = sapply(out, function(x) {
      ifelse(
        !is.null(x$params$label), x$params$label, NA
      )
    }),
    params = lapply(out, function(x) {
      if (!is.null(x$params) &&
        (is.null(x$params$engine) || x$params$engine == "r")) {
        # if chunk is not 'r' chunk, it must be accounted as text
        x$params
      } else {
        NA
      }
    }),
    text = lapply(out, function(x) {
      if (inherits(x, "inline")) {
        unlist(strsplit(x$input, "\n"))
      } else if (
        !is.null(x$params) &&
          !is.null(x$params$engine) &&
          x$params$engine != "r"
      ) {
        knitr::knit_code$get(x$params$label)
      } else {
        NA
      }
    }),
    code = lapply(out, function(x) {
      if (
        !is.null(x$params) &&
          !is.null(x$params$engine) &&
          x$params$engine != "r"
      ) {
        NA
      } else if (inherits(x, "block")) {
        knitr::knit_code$get(x$params$label)
      } else {
        NA
      }
    })
  )

  return(res)
}

#' split_headers_in_text
#' @noRd
split_headers_from_text <- function(the_text) {
  new_group <- rep(FALSE, length(the_text))
  which_header <- grep("^#", the_text)
  if (length(which_header) != 0) {
    new_group[which_header] <- TRUE
    # Change group just after header
    which_header_plus <- 1 + which_header[
      (which_header + 1) <= length(new_group)
    ]
    if (length(which_header_plus) != 0) {
      new_group[which_header_plus] <- TRUE
    }
    groups <- cumsum(new_group)
    groups[which_header] <- paste0(groups[which_header], "-heading")

    split_text <- split(the_text, groups)
  } else {
    split_text <- list(the_text)
  }
  return(split_text)
}
